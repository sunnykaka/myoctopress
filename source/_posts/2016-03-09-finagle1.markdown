---
layout: post
title: "微服务框架Finagle介绍"
date: 2016-03-19 21:33:12 +0800
comments: true
categories: [微服务, Scala, Java, 分布式]
description: "微服务框架Finagle介绍"
---

微服务架构可能是时下最热的一种架构模式了. 这篇系列里, 我想通过介绍一些常用的微服务框架,
来讨论一下实现整个微服务过程中会遇到哪些问题, 以及这些微服务框架是如何帮助我们解决这些问题的.

微服务不同于单一架构应用, 是典型的分布式场景, 各服务之间通过IPC进行通信. 实现微服务的过程中, 我们需要解决以下问题:
1. 服务注册和服务发现.
2. 根据应用选择合适的通信协议和数据协议.例如可以选用thrift, protocol buffer或REST.
3. 服务负载均衡.一个服务一般会部署多个实例. 如何使客户端请求压力合理地分布到各个实例上是需要考虑的问题.
4. 服务路由与限流.
5. 容错处理.相对于单机应用, 分布式环境下错误发生的概率会大大提高, 服务宕机, 网络不可用的情况时常发生.
6. 服务监控.各服务实例的性能指标, 例如请求响应时间, 请求并发数量, 以及服务实例的部署数量等,
都是需要密切关注的数据.
7. 事务一致性.

好的微服务框架应该能帮助我们解决上面的全部或者大部分问题. 这里我选择JVM上比较热门的三个微服务框架(Finagle,
  Spring Cloud(Eureka), Dubbox). 我会从实例入手, 介绍这些框架的使用方式, 优缺点和适用场景.

首先来看Finagle.
[Finagle](http://twitter.github.io/finagle)是Twitter在2011年开源的一款RPC框架, 在国外使用较多,
例如Pinterest, Nest, Tumblr, 感兴趣的可以Google. Finagle有着较为丰富的生态圈, 可以使用[Finch](https://github.com/finagle/finch)方便的实现REST, 使用[Finagle OAuth2](https://github.com/finagle/finagle-oauth2)实现OAuth认证, 使用[zipkin](http://twitter.github.io/zipkin/)实现服务监控. Finagle使用Scala开发, 官方宣称同时支持Scala和Java语言.

Finagle有三个核心概念: Future, Service, Filter.
1. Future.
Finagle使用的Future是`com.twitter.util.Future`. 由于Future非常实用, 从Scala2.10开始被加入到官方库`scala.concureent.Future`. Java8中也引入了一个类似的接口`java.util.concurrent.CompletableFuture`.
Future是对异步操作的抽象, 你可以将Future理解为一个容器, 这个容器包含一个异步操作. 一个Future容器可能处于三个状态中的一种: 异步操作还没有完成, 操作已经完成了并包含了成功结果, 操作失败并包含了异常结果. Future一种很常用的用法是可以注册成功或失败的回调函数, 例如下面的Java代码:
```java
responseFuture.onSuccess(func(response -> {
    System.out.println(String.format("response status: %s, response string: %s",
            response.status().toString(), response.contentString()));
    return BoxedUnit.UNIT;
}));
responseFuture.onFailure(func(e -> {
    System.out.println("error: " + e.toString());
    return BoxedUnit.UNIT;
}));
```
我在`responseFuture`上注册了一个成功的回调函数和失败的回调函数, 当Future对应的操作完成时, 会简单的打印出结果或异常信息.
Future另外一个十分强大的用法是组合.例如下面的Scala代码:
```scala
val authenticatedUser: Future[User] =
    User.authenticate(email, password)
 
val lookupTweets: Future[Seq[Tweet]] =
    authenticatedUser flatMap { user =>
      Tweet.findAllByUser(user)
    }

//#1
```
我解释下这段代码的执行逻辑. 首先调用`User.authenticate(email, password)`方法, 将返回的Future对象赋给authenticatedUser变量.
然后调用authenticatedUser的flatMap方法, 传入一个回调函数. 代码执行到#1位置的时候, 其实Future对应的操作并没有执行. 记住我们之前说过的,
Future是一个异步操作的抽象. 异步操作可能是由其他线程执行. flatMap的作用是可以对Future进行组合. 例如上面的代码, 只有在`User.authenticate(email, password)`的Future操作成功完成时, `Tweet.findAllByUser(user)`这段代码才会得到执行.

如果你了解函数式编程, 可以看出来Finagle中的Future近似于Monad(单子), 对单子感兴趣的可以参考[我之前的文章](http://skaka.me/blog/2015/12/19/functor-applicative-monad-scala-haskell/).

其实你用callback的写法也能完成上面的代码逻辑.只是FlatMap的用法更加自然, 写起来好像是同步代码, 实际上可以是异步执行的.

2. Service


在介绍Finagle的相关概念之前
我分别使用Java和Scala实现一个echo的示例.
